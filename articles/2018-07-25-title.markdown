---
layout: post
title: "Developing modern web apps with Polymer and LitElement"
description: "Use cutting edge web technologies including LitHTML, LitElement and Polymer to create performant, modular websites."
date: "2018-07-25 08:30"
author:
  name: "Mark Wheeler"
  url: "@pixelcodeuk"
  mail: ""
  avatar: "https://twitter.com/@pixelcodeuk/profile_image?size=original"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

**TL;DR:** In this article, you're going to use web components to create a simple todo list [SPA (Single Page Application)](https://en.wikipedia.org/wiki/Single-page_application). You'll use Auth0 to secure the list, Redux to manage the state of the application, and LitElement to add some syntactic sugar.

## What is Polymer/LitElement?

The [Polymer project](https://www.polymer-project.org) started in 2012 with a mission to improve the state of web development, and drive the web platform forward. They proposed a new spec that would allow complex web applications to be built easily, and have native API's to create web components that are reusable.

### What are web components?

[Web components](https://www.webcomponents.org) are a suite of standards that allow you to create reusable custom components on the web. The suite includes:

* Custom elements

The ability to create your own tags, like the ones built into browsers (buttons etc).

* Shadow DOM

The ability to encapsulate your components (see below).

* HTML templates

The ability to define a template in HTML, that would not be rendered, but could be instantiated as and when it is needed.

### What is the Shadow DOM?

One of the fundamental aspects of the new spec was the ability to encapsulate each component. No more ingrained CSS naming conventions. Even if two components had exactly the same CSS class names they would not (and could not) be inadvertently modified from the outside. But what if you want to share CSS amongst multiple components, for a company colour scheme for example? Using [custom CSS properties and mixins](https://www.polymer-project.org/3.0/docs/devguide/custom-css-properties) you can explicitly define how to inject CSS into custom elements.

## What is Redux?

[Redux](https://redux.js.org) is a state container. It will hold the current state of your app, including all the todo items, the user details, and anything else you need. The state is stored as a JSON object that is immutable. When you need to make a change, you create new object that has all the data from the previous object plus the change being made.

You will subscribe your web components to Redux, in a way that your code will be told every time a change of state occurs so you can update your views.

Redux has three major concepts outlined in the image below:

![Redux](state.png)

The *store* is the state contained in a JSON object. An *action* tells Redux that an event has happened that will change the state of the system. The *reducer* takes the old state, and the action, and provides a new immutable state. This new state then gets automatically sent to your components. All you need to do is define what actions you need, and how those actions affect the state. The read more about Redux, see [this article](https://auth0.com/blog/redux-practical-tutorial/).

## Basic structure of the Polymer app

Your SPA will contain some web components, some actions and reducers (for Redux) and a simple HTML file as the starting point. You will create a folder structure as follows:

* `src / actions`
* `src / components`
* `src / reducers`

Locate the folder you want to store your project, then run the following command:

```sh
mkdir -p src/actions src/components src/reducers
```

To keep things simple, you'll put all of your actions and reducers in one file (rather than separate them out).

To build and serve your project, you'll use [Webpack](https://webpack.js.org) and the [Polymer CLI](https://github.com/Polymer/tools/tree/master/packages/cli). Web components are implemented directly into the browser, so you can run them without compilation. The only problem is you will import the LitElement code by package name, and browsers do not currently know how to find code referenced that way. Webpack will take care of that for you.

### Polymer/LitElemenent dependencies

Let's get started. Run the commands below from inside the root of your project folder:

```sh
#Fill in the details of your repo
npm init
#Install dependencies
npm install --save @polymer/lit-element auth0-js pwa-helpers redux redux-thunk
#Install dev dependencies
npm install --save-dev polymer-cli webpack webpack-cli
```

### Setting up Webpack to compile your code

As your app is a SPA, it will have a single point of entry. You will be talking to an API, so you need to make the API address available to your code. Create a file called `webpack.dev.conf.js` and put the following code inside:

```js
<!-- webpack.dev.conf.js -->
const webpack = require('webpack');

module.exports = {
  entry: './src/components/my-app.js',
  output: {
    filename: 'main.js',
  },
  mode: 'development',
  plugins: [
    new webpack.DefinePlugin({
      'API_URL': '"http://localhost:3000"',
    })
  ]
};

```

With this configuration, Webpack will compress your code into `dist/main.js`. A constant called `API_URL` will be injected by Webpack during that process so anywhere Webpack sees this constant it will replace the value for you.

### Setting your LitElement start page

The greatest asset of web components is encapsulation. Each element knows how to handle itself, which makes developing for the web easier. Create a file called `index.html` in the project root with the following contents:

{% highlight html %}
<!-- index.html -->
<html>
<body>
<my-app appTitle="my app"></my-app>
<script src="dist/main.js"></script>
</body>
</html>
{% endhighlight %}

That's it! You import the web component you are going to make using JavaScript (`<my-app>`), and then use the component like any other HTML tag.

### Polymer app build script setup

Now that you have all your dependencies setup, you will make a few scripts to make compilation easy, add these lines to your `package.json`.

```js
"scripts": {
  "webpack_dev": "webpack --config webpack.dev.conf.js",
  "serve": "polymer serve",
  "start": "npm run-script webpack_dev && npm run-script serve"
},
```

You have defined 3 scripts above. `webpack_dev` will combine all your code, `serve` will serve your code to the browser for testing and `start` will compile and run your code all in one.


### Auth0 setup

You are going to secure your app using Auth0. Follow [their guide](https://auth0.com/docs/applications/spa) to register an App and get credentials you will need to communicate with Auth0. Make a note of the `domain`, `audience` and `clientId`.


### Hapi Backend

In the first part of this article you created a backend to process and store your todos. Run the [backend code](https://github.com/brunokrebs/polymer-hapijs-auth0) so your components can connect to the API.


## Make your first web component with LitElement

The app you will make is a todo list that lets users add and delete items. You will make 3 web components:

![Basic app outline](state2.png)

`my-app` will contain all of your app. You could share the component with others, and they could implement an entire todo list with one line of code! `my-list` will take data from your Redux store, and display all the items in the todo list array. Redux will inform the component when the array changes. `auth0-login` will keep your Redux store informed of the state of the user authentication.

Let's start by making `my-list`. Create a file called `my-list.js` inside the `components` directory. As discussed it will take an array as input, and display the items. You need a way to delete each element, and you'll also add a textbox at the bottom to allow the user to add new todo's.

```js
<!-- src/components/my-list.js -->
import {LitElement, html} from '@polymer/lit-element';

class MyList extends LitElement {
  static get properties() {
    return {
      items: Array,
    };
  }

  _render(properties) {

      //You will fill this in later...

  }
}

window.customElements.define('my-list', MyList);
```

The code above is the boilerplate needed for your element. Give it a name `my-list` and give it one property `items` of type `Array`. You import and extend LitElement that will give you some nice features (notice how you import it by package name). You declare properties (attributes on your custom HTML element) and give them appropriate types.

Let's finish your `_render` function:

```js
_render(properties) {
return html`
  <style>
    .spinner {
      position: relative;
      width: 20px;
      height: 20px;
      padding-left: 10px;
      padding-right: 20px;
      background-color: #ccc;
    }
  </style>

  <ul>
    ${properties.items.map((item, index) => html`
      <li>
        ${item.name} <span hidden?="${!(item.loading || item.deleting)}" class="spinner"></span>
        <span hidden?="${item.deleting || item.loading}" on-click="${() => this._deleteEntry(index)}">(Delete)</span>
      </li>
    `)}
  </ul>

  <input type="text" id="todo" />
  <button on-click="${() => this._addEntry()}">Add</button>
}
`;

```

The render function takes one argument `properties`, which is an object containing all the properties you defined earlier (`items`).

You make a [template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) in JavaScript so you can write your CSS and HTML. The CSS you make creates a spinner that you will show whilst you wait for the backend to respond to your requests.

The first interesting section is the unordered list you make. As you are using templates, you can use `${ }` to inject any JavaScript you want! You enumerate over the items to produce the list (notice how the map function returns another template). You have a span that you hide or show when you are waiting for the backend. Finally you display the name of the item using `${item.name}`. Using LitElement you can also define event handlers directly in your code. You make two handlers `_deleteEntry` and `_addEntry`.

Let's extend your web component object with these new handers:

```js
// ... import statements ...
class MyList extends LitElement {
  // ... properties and _render definitions ...

  _addEntry() {
    this.dispatchEvent(new CustomEvent('add-entry', {detail: this.shadowRoot.querySelector('#todo').value}));
  }
  
  _deleteEntry(index) {
    this.dispatchEvent(new CustomEvent('delete-entry', {detail: index}));
  }
}
```

In this code you use native custom events to send two different events. One for deleting an item (along with its index), and another to create an item. Notice how you got the value of the textbox: `this.shadowRoot.querySelector`. You are not in Kansas anymore, you are no longer dealing with the `document` directly, all of your code is placed in a shadow DOM, encapsulated from everything else (another way of thinking of the Shadow DOM is like a mini document created specifically for your element).

For UX bonus points, you will cause a focus event on the textbox onload:

```js
// ... import statements ...
class MyList extends LitElement {
  // ... properties, _render, _addEntry and _deleteEntry definitions ...

  _didRender(props, changedProps, prevProps) {
    super._didRender(props, changedProps, prevProps);

    this.shadowRoot.querySelector('#todo').focus();
  }
}
```

What's going on here? You need to wait for your web component to be initialised before you can cause focus. [LitElement](https://github.com/Polymer/lit-element) describes the lifecycle of the component from load to launch. You intercept the function called after the element is rendered on screen and then focus the element.

The value you return from `_render` is a [tagged template](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals). You import the function `html` from LitElement, this function will take your template and transform it for us.

## Make an Auth0 web component with LitElement

What you are going to do next is an interesting way to use web components. You are going to use the JS library made by Auth0 to keep track of the user authentication state. However, you will take advantage of the encapsulation provided by web components and make an element whose sole job is tracking authentication information. When you are finished, the element could be reused anywhere, by anyone, to add Auth0 authentication in one line!!

The full code is below, you'll cover the interesting parts, as the rest is just a wrapper around the Auth0 JS library. Create a file called `auth0-login.js` in the `components` directory.

```js
<!-- src/components/auth0-login.js -->
import {LitElement, html} from '@polymer/lit-element';

const auth0 = require('../../node_modules/auth0-js/build/auth0.js');

class Auth0Login extends LitElement {
  static get properties() {
    return {
      _auth: Object,
      _user: Object,
      audience: String,
      clientid: String,
      audience: String,
      responsetype: String,
      scope: String,
      domain: String,
    };
  }

  _render(properties) {
    return html`
      <button hidden?="${properties._user != null}" on-click="${() => this.login()}">Login</button>
      <button hidden?="${properties._user == null}" on-click="${() => this.logout()}">Logout</button>
    `;
  }

  login() {
    this._auth.authorize();
  }

  _getProfile() {
    this._auth.client.userInfo(this._user.accessToken, (err, profile) => {
      this.dispatchEvent(new CustomEvent('user-login', {detail: profile}));
    });
  }

  _handleAuthentication() {
    this._auth.parseHash((err, authResult) => {
      if (authResult && authResult.accessToken && authResult.idToken) {
        window.location.hash = '';
        this._setSession(authResult);
        this._user = authResult;
        this._getProfile();
      } else {
        if (this.isAuthenticated()) {
          this._user = {
            accessToken: localStorage.getItem('access_token'),
            idToken: localStorage.getItem('id_token'),
            expiresAt: localStorage.getItem('expires_at'),
          };
          this._getProfile();
        }
      }
    });
  }

  _firstRendered() {
    super._firstRendered();
    this._auth = new auth0.WebAuth({
      domain: this.domain,
      clientID: this.clientid,
      responseType: this.responsetype,
      audience: this.audience,
      scope: this.scope,
      redirectUri: window.location.href
    });
    this._handleAuthentication();
  }

  _setSession(authResult) {
    const expiresAt = JSON.stringify(
      authResult.expiresIn * 1000 + new Date().getTime()
    );
    localStorage.setItem('access_token', authResult.accessToken);
    localStorage.setItem('id_token', authResult.idToken);
    localStorage.setItem('expires_at', expiresAt);
  }

  logout() {
    localStorage.removeItem('access_token');
    localStorage.removeItem('id_token');
    localStorage.removeItem('expires_at');
    this._user = null;
    this.dispatchEvent(new CustomEvent('user-logout'));
  }

  isAuthenticated() {
    var expiresAt = JSON.parse(localStorage.getItem('expires_at'));
    return new Date().getTime() < expiresAt;
  }
}

window.customElements.define('auth0-login', Auth0Login);
```

Your `_render` function has a simple login and logout button, you use the `user` property to detect authentication information to toggle the buttons.

The `_firstRendered` function gets called only when the element is first rendered, you use this to check if the user is already logged in when your webpage loads.

The `_getProfile` function gets the information for the user and uses a custom event to bubble the information (to be caught by Redux).

The other functions in this object are wrappers around the [Auth0 JS library](https://auth0.com/docs/libraries/auth0js/v9).

This web component accepts the Auth0 configuration as input, so it can be reused anywhere. Anyone can import this one component and have the full power of the Auth0 library!

What's particularly interesting about this component is that it doesn't necessarily need a view. Like the `<script>` tag you could make an element that has no presentation of its own, purely dealing with data modelling. This leads to interesting possibilities for web components be using to define data as well as presentation.

## Creating your state strategy with Redux

Before you make the final web component for your app, lets make the state for the app. Place this boilerplate into the file `store.js` in the `src` directory.:

```js
<!-- src/store.js -->
import {createStore,applyMiddleware} from 'redux';
import thunk from 'redux-thunk';
import {reducer} from './reducers/app.js'

export const store = createStore(reducer, applyMiddleware(thunk));
```

This code sets up your global data store. You initialise Redux, and apply Thunk middleware (more on this later).

If you remember from the introduction above, actions tell Redux when something happens that will change the state of the app. An action is a function that returns a JSON object that describes the action and any data associated with it  (Thunk allows you to access Redux so you do not need to return immediately, but can await a backend response). Create a file called `app.js` in the `actions` directory and add the following code:

```js
<!-- src/actions/app.js -->
export const ADD_ITEM_START = 'ADD_ITEM_START';
export const ADD_ITEM_FINISH = 'ADD_ITEM_FINISH';
export const ADD_ITEM_FAILED = 'ADD_ITEM_FAILED';
export const DELETE_ITEM_START = 'DELETE_ITEM_START';
export const DELETE_ITEM_FINISH = 'DELETE_ITEM_FINISH';
export const USER_LOGIN = 'USER_LOGIN';
export const USER_LOGOUT = 'USER_LOGOUT';
export const INIT_LOADING_START = 'INIT_LOADING_START';
export const INIT_LOADING_END = 'INIT_LOADING_END';

export const addItem = (item) => (dispatch) => {
  const jwt = localStorage.getItem('access_token');
  if (!jwt) return;

  dispatch({
    type: ADD_ITEM_START,
    item,
  });

  fetch(API_URL + '/todo', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${jwt}`
    },
    body: JSON.stringify({
      item,
    })
  }).then((response) => {
    if (response.status === 201) {
      dispatch({
        type: ADD_ITEM_FINISH,
        item,
      });
    } else {
      dispatch({
        type: ADD_ITEM_FAILED,
        item,
      });
    }
  }).catch(e => {
    dispatch({
      type: ADD_ITEM_FAILED,
      item,
    });
  });
};

export const deleteItem = (index) => (dispatch) => {
  const jwt = localStorage.getItem('access_token');
  if (!jwt) return;

  dispatch({
    type: DELETE_ITEM_START,
    index,
  });

  fetch(API_URL + '/todo', {
    method: 'DELETE',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${jwt}`
    },
    body: JSON.stringify({
      index,
    })
  }).then((response) => {
    dispatch({
      type: DELETE_ITEM_FINISH,
      index
    });
  });
};

export const userLogin = (user) => (dispatch) => {
  dispatch({
    type: USER_LOGIN,
    user: user
  });
};

export const userLogout = () => (dispatch) => {
  dispatch({
    type: USER_LOGOUT
  });
};

export const getInitialData = () => (dispatch) => {
  const jwt = localStorage.getItem('access_token');
  if (!jwt) return;

  dispatch({
    type: INIT_LOADING_START
  });

  fetch(API_URL + '/todo', {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${jwt}`
    },
  }).then(function (response) {
    return response.json();
  }).then((response) => {
    dispatch({
      type: INIT_LOADING_END,
      items: response.value || []
    });
  });
};
```

Let's look at the `addItem` action.

This action is fired when a new item is added to your todo list. All it does is tell the API to add an item. The first thing you do is inform Redux that you are going to try to add an item by dispatching `ADD_ITEM_START`. If you remember when you made the `<my-list>` element, you made a spinner whilst you wait for the API. This action will cause that spinner to show on screen.

You load the JWT token from `localStorage` and send a `POST` request to the backend, depending on the response from the backend you dispatch either `ADD_ITEM_FINISH` or `ADD_ITEM_FAILED` to Redux. One will add the item, one will tell Redux something went wrong.

The action itself is a function which accepts an `item` and then returns a `function` that accepts `dispatch`. Thunk will take care of giving us `dispatch` so you can send as many actions to Redux as you want.

The other actions in the repo follow the same pattern. They tell Redux something has happened, and send any data that is needed.

## The Redux Reducer

A reducer is a fancy word for code that gets the old state of the system, and makes a change.

Create a file called `app.js` in the `reducers` folder and add the following code:

```js
<!-- src/reducers/app.js -->
import {
  ADD_ITEM_START,
  ADD_ITEM_FINISH,
  ADD_ITEM_FAILED,
  DELETE_ITEM_START,
  DELETE_ITEM_FINISH,
  USER_LOGIN,
  USER_LOGOUT,
  INIT_LOADING_START,
  INIT_LOADING_END,
} from '../actions/app.js';

const initialState = {
  user: null,
  loadingdata: false,
  loadinginitial: false,
  items: [],
};

export const reducer = (state, action) => {
  if (!state) return initialState;
  let items;

  switch (action.type) {
    case INIT_LOADING_START:
      return Object.assign({}, state, {
        loadinginitial: true,
      });

    case INIT_LOADING_END:
      return Object.assign({}, state, {
        items: action.items.map((elem) => {
          return {name: elem, loading: false}
        }),
        loadinginitial: false,
      });

    case ADD_ITEM_START:
      items = state.items.slice(0);
      items.unshift({
        name: action.item,
        loading: true
      });

      return Object.assign({}, state, {
        items: items,
        loadingdata: true,
      });

    case ADD_ITEM_FINISH:
      items = state.items.slice(0);
      delete items[0].loading;
      return Object.assign({}, state, {items});

    case ADD_ITEM_FAILED:
      items = state.items.slice(0, -1).shift();
      return Object.assign({}, state, {items});

    case DELETE_ITEM_START:
      items = state.items.slice(0);
      items[action.index].deleting = true;
      return Object.assign({}, state, {items});

    case DELETE_ITEM_FINISH:
      items = state.items.slice(0);
      items.splice(action.index, 1);
      return Object.assign({}, state, {items});

    case USER_LOGIN:
      return Object.assign({}, state, {user: action.user});

    case USER_LOGOUT:
      return initialState;
  }
};

```

As you can see from the definition, a reducer takes the current state of the system, and one action, and has to return the new state of the system.

You have 3 cases to look at in your `ADD_ITEM` example, that of starting to add an item (waiting for the backend), the completion of adding an item, and the case where it fails.

You use `Object.assign` to create a new object, with a copy of the old one plus your changes (the state in Redux is immutable).

The data model for your todo item is as follows:

```js
{
  name,        //todo description
  loading,     //adding to database?
  deleting     //deleting from database?
}
```

## Wiring your components together with Redux and LitElement

Your final element will talk to Redux and keep the UI informed of the state.

The creation of this element is slightly different, make a file called `my-app.js` and place it in the `components` folder:

```js
<!-- src/components/my-app.js -->
import {LitElement, html} from '@polymer/lit-element';
import {connect} from 'pwa-helpers/connect-mixin.js';
import {store} from '../store.js';
import './my-list.js';
import './auth0-login.js';

import {
  addItem,
  deleteItem,
  userLogin,
  userLogout,
  getInitialData,
} from '../actions/app.js';

class MyApp extends connect(store)(LitElement) {
  static get properties() {
    return {
      _count: Number,
      _signedIn: Boolean,
      _items: Array,
    };
  }

  _render(properties) {
    return html`
      Todo list (${properties._count})

      <auth0-login
        domain="domain"
        clientid="clientid"
        audience="http://localhost:3000"
        scope="openid profile"
        responsetype="token id_token"
        on-user-login="${(e) => this._userLogin(e)}"
        on-user-logout="${() => this._userLogout()}"
      ></auth0-login>

      <div hidden="${!properties._signedIn}">
        <my-list items="${properties._items}"
          on-delete-entry="${(e) => this._deleteEntry(e)}"
          on-add-entry="${(e) => this._addEntry(e)}"
        ></my-list>
      </div>
    `;
  }

  _deleteEntry(e) {
    store.dispatch(deleteItem(e.detail));
  }

  _addEntry(e) {
    store.dispatch(addItem(e.detail));
  }

  _userLogin(e) {
    store.dispatch(userLogin(e.detail));
    store.dispatch(getInitialData(e.detail));
  }

  _userLogout() {
    store.dispatch(userLogout());
  }

  _stateChanged(state) {
    this._count = state.items.length;
    this._signedIn = state.user != null;
    this._items = state.items;
  }

  _firstRendered() {
    super._firstRendered();
    store.dispatch(getInitialData());
  }
}

window.customElements.define('my-app', MyApp);

```

Our final component uses both LitElement and `connect` which binds Redux to your app. All the state change propagation is automatically handled for us.

```js
static get properties() {
  return {
    _count: Number,
    _signedIn: Boolean,
    _items: Array,
  };
}

_stateChanged(state) {
    this._count = state.items.length;
    this._signedIn = state.user != null;
    this._items = state.items;
  }
```

Your component has properties, but they are all private (marked by a leading underscore). They get their values from Redux in the `_stateChanged` function rather than using attributes (e.g. `<my-app _count="1">`);

In your previous elements, you used custom events to *bubble* data to higher elements. You now need to catch these events and do something with them. You made actions earlier that cause Redux to change state, so you need to pass the data from the event to the Redux action:

```js
_addEntry(e) {
  store.dispatch(addItem(e.detail));
}
```

This function catches the `addEntry` event, and uses the `addItem` action you made earlier to tell Redux what to do using the `dispatch` method.

## Serving the final Polymer web app

You have made 3 custom web components, wired them to Redux and authenticated them with Auth0.

To launch the project run:

```sh
npm start
```
And go to the web address provided.

## Conclusion

What have you learned in this article? You have made custom web components using nothing but vanilla JS and some helper functions provided by Polymer and LitElement. When browsers know how to use package names to import code, you could run your vanilla code with no further config! You used vanilla custom events to pass data around the hierarchy, and vanilla JS to describe your templates.

This is in contrast to React with the VDOM, you do not need any artificial constructs, the browser does all the heavy lifting!

## Thinking further

One of the advantages of web components is that they are sharable, but you have baked in an assumption about your data system (calling preset API endpoints). Can you think of a way to remove this dependency to make these components truly reusable (hint: custom events)?
